import java.io.*;
import java_cup.runtime.*;
import java.util.*;

parser code {:
    public boolean DEBUG = true;

    public static void printTree(Node<String> node, int depth) {
        for (int i = 0; i < depth; ++i)
            if (i == depth - 1)
                System.out.print("|-");//\u22A2');
            else
                System.out.print("  ");
        System.out.println(node.getData());
        List<Node<String>> kids = node.getChilds();
        for (Node<String> kid : kids) {
            printTree(kid, depth + 1);
        }
    }

    public void syntax_error(Symbol cur_token) {
        System.err.println("Syntax error at " + cur_token);
        report_error("Syntax error", cur_token);
    }

    public void Debuglog(String s) {
        if (DEBUG)
            System.out.println(s);
    }

    public Node<String> makeNode(String s, Object... arr) {
        Node<String> List = new Node<String>(s, -1, -1);
        boolean exist = false;
        for (Object a: arr) {
            Node<String> tmp = (Node<String>) a;
            List.appendChild(tmp);
            if (!exist) {
                exist = true;
                List.r = tmp.r;
                List.c = tmp.c;
            }
        }
        return List;
    }

    public Node<String> makeName(Object name) {
        if (name instanceof String)
            return new Node<String>("%" + (String)name, -1, -1);
        Symbol tmp = (Symbol) name;
        return new Node<String>(tmp.toString(), tmp.left, tmp.right);
    }

    public Node<String> makeOp(String s) {
        if (s instanceof String)
            return new Node<String>((String)s, -1, -1);
        return new Node<String>("#" + s, -1, -1);
    }

    public Node<String> makeOp(Object op) {
        if (op == null) {
            return new Node<String>("#null at makeOp(Object op)", -1, -1);
        }
        if (DEBUG)
            System.err.println("makeOp: " + op.getClass());
        if (op instanceof String)
            return makeOp((String) op);
        Symbol tmp = (Symbol) op;
        return new Node<String>("#" + tmp.toString(), tmp.left, tmp.right);
    }

    public Node<String> makeNumber(Object nb) {
        if (nb instanceof String)
            return new Node<String>((String)nb, -1, -1);
        Symbol tmp = (Symbol) nb;
        return new Node<String>(tmp.toString(), tmp.left, tmp.right);
    }

    public Node<String> makeKeyword(Object kw) {
        if (kw instanceof String)
            return new Node<String>((String)kw, -1, -1);
        Symbol tmp = (Symbol) kw;
        return new Node<String>(tmp.toString(), tmp.left, tmp.right);
    }

    public Node<String> makeString(Object s) {
        if (s instanceof String)
            return new Node<String>((String)s, -1, -1);
        //TODO: string
        return new Node<String>("stirng_td", -1, -1);
    }

    public static void main(String args[]) {
        try {
            Lexer lexer = new Lexer(new FileReader(args[0]));
            
            Parser p = new Parser(lexer);
            System.out.println("Parser init\n");

            p.parse();
            //p.debug_parse();

            System.out.println("Finish\n");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public void copyChild(Node<String> a, Node<String> b) {
        List<Node<String>> kids = b.getChilds();
        for (int i = 0; i < kids.size(); ++i) {
            a.appendChild(kids.get(i));
        }
    }
:};

terminal ERROR;
terminal NUMBER, STRING;
terminal FALSE, TRUE, NONE, NAME, ELLIPSIS;
terminal AND, AS, ASSERT, ASYNC, AWAIT;
terminal BREAK, CLASS, CONTINUE, DEF, DEL;
terminal ELIF, ELSE, EXCEPT, FINALLY, FOR, FROM;
terminal GLOBAL, IF, IMPORT, IN, IS, LAMBDA, NONLOCAL, NOT;
terminal OR, PASS, RAISE, RETURN, TRY;
terminal WHILE, WITH, YIELD;
terminal LPAR, RPAR, LSQB, RSQB, COLON, COMMA, SEMI;
terminal PLUS, MINUS, STAR, SLASH, VBAR, AMPER;
terminal LESS, GREATER, EQUAL, DOT, PERCENT, LBRACE, RBRACE;
terminal CIRCUMFLEX, TILDE, AT;
terminal EQEQUAL, NOTEQUAL, LESSEQUAL, LEFTSHIFT, GREATEREQUAL, RIGHTSHIFT;
terminal PLUSEQUAL, MINEQUAL, RARROW, DOUBLESTAR, STAREQUAL, DOUBLESLASH, SLASHEQUAL, VBAREQUAL;
terminal PERCENTEQUAL, AMPEREQUAL, CIRCUMFLEXEQUAL, ATEQUAL;
terminal LEFTSHIFTEQUAL, RIGHTSHIFTEQUAL, DOUBLESTAREQUAL, DOUBLESLASHEQUAL;
terminal INT, NEWLINE;
terminal INDENT, DEDENT;
terminal UNARY, COMP, BIT, ADDISH, MULISH;

nonterminal Node<String> program;
nonterminal Node<String> file_input;
//nonterminal Node<String> file_input_unit;
nonterminal Node<String> decorator, decorators, decorated;
nonterminal Node<String> funcdef;
nonterminal Node<String> parameters, arglist, probinittfpdef, tfpdef;
nonterminal Node<String> stmt, simple_stmt, small_stmts, small_stmt, expr_stmt;
nonterminal Node<String> annassign;
nonterminal Node<String> del_stmt, pass_stmt, flow_stmt, break_stmt, continue_stmt, return_stmt, raise_stmt, ipt_stmt;
nonterminal Node<String> ipt_name;
nonterminal Node<String> ipt_as_names;
nonterminal Node<String> assert_stmt, compound_stmt;
nonterminal Node<String> if_stmt, elif_stmts, while_stmt, try_stmt, except_stmts;
nonterminal Node<String> except_clause, suite, stmts;
nonterminal Node<String> expr;
nonterminal Node<String> comp_op, bit_op, addish_op, mulish_op, unary_op, trailers;
nonterminal Node<String> atom, strings;
nonterminal Node<String> trailer;
nonterminal Node<String> exprlist, exprlist_sub;
nonterminal Node<String> dictmaker, setmaker, dictmaker_sub, setmaker_sub;
nonterminal Node<String> classdef;
nonterminal Node<String> labeledType, ifLabel, unitIfLabel, maybeLabeledName;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence left COMP, LESS, GREATER, EQEQUAL, GREATEREQUAL, LESSEQUAL, NOTEQUAL, IN, IS;
precedence left BIT, VBAR, CIRCUMFLEX, AMPER, LEFTSHIFT, RIGHTSHIFT;
precedence left ADDISH, PLUS, MINUS;
precedence left MULISH, STAR, AT, PERCENT, SLASH, DOUBLESLASH;
precedence left UNARY;
precedence right DOUBLESTAR;


start with program;

program ::= file_input:list {:
        printTree(list, 0);
        RESULT = list;
    :};

//Information flow specific modification
labeledType ::= NAME:a LBRACE ifLabel:b RBRACE {:
        RESULT = makeNode("labeledType", makeName(a), b);
    :};
ifLabel ::= unitIfLabel:a {:
        RESULT = makeNode("ifLabel", a);
    :} 
    | ifLabel:a AND ifLabel:b {:
        RESULT = makeNode("ifLabel", a, makeOp("AND"), b);
    :}
    | ifLabel:a OR ifLabel:b {: RESULT = makeNode("ifLabel", a, makeOp("OR"), b); :};
unitIfLabel ::= NAME:a {: RESULT = makeName(a);:} 
    | LPAR ifLabel:a RPAR {:RESULT = a; :};

decorator ::= AT NAME:a NEWLINE {:RESULT = makeNode("decorator", makeName(a));:};
decorators ::= 
    decorator:a {:RESULT = makeNode("decorators", a);:}
    | decorators:list decorator:a {:
        list.appendChild(a);
        RESULT = list;
    :};
decorated ::= 
    decorators:a classdef:b {:RESULT = makeNode("decorated", a, b);:}
    | decorators:a funcdef:b {:
        RESULT = makeNode("decorated", a, b);
    :};

//file_input: (NEWLINE | stmt)* ENDMARKER
file_input ::= 
    file_input:fi stmt:fiu {: 
        Debuglog("Debug: 1");
        Node<String> List = fi;

        if (fiu != null) {
            List.appendChild(fiu);
        }
        RESULT = List;
    :}
    | stmt:a {: 
        Debuglog("Debug: 2"); 
        Node<String> List = new Node<String>("file_input", -1, -1);
        List.appendChild(a);
        RESULT = List;
    :};

//file_input_unit ::= NEWLINE {: RESULT = makeNode("NEWLINE"); :}
//    | stmt:a {: RESULT = a; :};

//eval_input: testlist NEWLINE* ENDMARKER


//funcdef: 'def' NAME parameters ['->' test] ':' suite
funcdef ::= 
    DEF maybeLabeledName:a parameters:b RARROW expr:c COLON suite:d {:RESULT = makeNode("funcdef", a, b, c, d);:}
    | DEF maybeLabeledName:a parameters:b COLON suite:c {:RESULT = makeNode("funcdef", a, b, c);:};
maybeLabeledName ::=
    NAME:a {:RESULT = makeName(a);:}
    | NAME:a LBRACE ifLabel:b RBRACE {:
        RESULT = makeNode("LabeledName", makeName(a), b);
    :};


//parameters: '(' [typedargslist] ')'
//typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
//        '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
//      | '**' tfpdef [',']]]
//  | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
//  | '**' tfpdef [','])
//tfpdef: NAME [':' test]
parameters ::= 
    LPAR arglist:a RPAR {:RESULT = makeNode("parameters", a);:}
    | LPAR RPAR {:RESULT = makeNode("parameters");:};
arglist ::= 
    probinittfpdef:a {:RESULT = makeNode("arglist", a);:}
    | arglist:list COMMA probinittfpdef:a {:
        list.appendChild(a);
        RESULT = list;
    :}; 
probinittfpdef ::=
    tfpdef:a  {:RESULT = makeNode("probinittfpdef", a);:}
    | tfpdef:a EQUAL expr:b {:RESULT = makeNode("probinittfpdef_=", a, b);:};
tfpdef ::= 
    NAME:a COLON expr:b {:RESULT = makeNode("tfpdef", makeName(a), b);:};

//stmt: simple_stmt | compound_stmt
//simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
//small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |
//             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
//expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
//                     ('=' (yield_expr|testlist_star_expr))*)
stmt ::= simple_stmt:a {: RESULT = a; :}
    | compound_stmt:a {: RESULT = a; :};
simple_stmt ::= small_stmts:a SEMI NEWLINE {: RESULT = a; :}
    | small_stmts:a NEWLINE {: RESULT = a; :}
    | NEWLINE {:RESULT = makeNode("NEWLINE");:};
small_stmts ::=
    small_stmt:a {: 
        Node<String> List = makeNode("small_stmts"); 
        if (a != null)
            List.appendChild(a);
        RESULT = List;
    :}
    | small_stmts:list SEMI small_stmt:a {:
        Node<String> List = list;
        if (a != null)
            List.appendChild(a);
        RESULT = List;
    :};
small_stmt ::= expr_stmt:a {: RESULT = a; :}
    | del_stmt:a {: RESULT = a; :}
    | pass_stmt:a {: RESULT = a; :}  
    | flow_stmt:a {: RESULT = a; :}  
    | ipt_stmt:a {: RESULT = a; :}  
    | assert_stmt:a {: RESULT = a; :} ;
expr_stmt ::= 
    expr:a {:RESULT = a;:}
    | expr:a annassign:b {://testlist_star_expr:a expr_rest_stmt:b {:
        Node<String> List = makeNode("expr_stmt", a, b);
        RESULT = List;
    :}
    | expr:a EQUAL expr:b {:
        Node<String> List = makeNode("expr_stmt", a, b);
        RESULT = List;
    :};

//annassign: ':' test ['=' test]
//testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
//augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
//            '<<=' | '>>=' | '**=' | '//=')
annassign ::= 
    COLON expr:a EQUAL expr:b {:
        Node<String> List = makeNode("annassign", a, b);
        RESULT = List;
    :}
    | COLON expr:a {:
        Node<String> List = makeNode("annassign", a);
        RESULT = List;
    :};

//# For normal and annotated assignments, additional restrictions enforced by the interpreter
// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]
// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
del_stmt ::= DEL exprlist:a {:
            Node<String> List = makeNode("del_stmt", a);
            RESULT = List;
        :};
pass_stmt ::= PASS {: RESULT = makeNode("PASS"); :};
flow_stmt ::= break_stmt:a {: RESULT = a;:}
        | continue_stmt:a {: RESULT = a;:}  
        | return_stmt:a {: RESULT = a;:}
        | raise_stmt:a {: RESULT = a;:};
break_stmt ::= BREAK {: RESULT = makeNode("BREAK"); :};
continue_stmt ::= CONTINUE {: RESULT = makeNode("CONTINUE"); :};
return_stmt ::= RETURN {: RESULT = makeNode("RETURN"); :}
    | RETURN expr:a {: 
        Node<String> List = makeNode("return_stmt", a);
        RESULT = List;
    :};
raise_stmt ::= RAISE {: RESULT = makeNode("RAISE"); :}
    | RAISE expr:a {:
        Node<String> List = makeNode("raise_stmt");
        List.appendChild(a);
        RESULT = a;
    :}
    | RAISE expr:a FROM expr:b {:
        Node<String> List = makeNode("raise_stmt");
        List.appendChild(a);
        List.appendChild(b);
        RESULT = a;
    :};
ipt_stmt ::= ipt_name:a {: RESULT = a; :};
ipt_name ::= IMPORT ipt_as_names:a {:
        Node<String> List = makeNode("import_name", a);
        RESULT = List;
    :};


// # note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
// import_as_name: NAME ['as' NAME]
// assert_stmt: 'assert' expr [',' expr]
ipt_as_names ::= 
    NAME:a {:RESULT = makeNode("import_as_name", makeName(a));:}
    | NAME:a AS NAME:b {:
        RESULT = makeNode("import_as_name", makeName(a), makeName(b));
    :};
assert_stmt ::= ASSERT expr:a COMMA expr:b {:
        RESULT = makeNode("assert_stmt", a, b);
    :}
    | ASSERT expr:a {:RESULT = makeNode("assert_stmt", a);:};


// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// try_stmt: ('try' ':' suite
//            ((except_clause ':' suite)+
//             ['else' ':' suite]
//             ['finally' ':' suite] |
//            'finally' ':' suite))
compound_stmt ::= if_stmt:a {:RESULT = a;:} 
    | while_stmt:a {:RESULT = a;:}
    | try_stmt:a {:RESULT = a;:} 
    | funcdef:a {:RESULT = a;:} 
    | classdef:a {:RESULT = a;:}
    | decorated:a {:RESULT = a;:}; 
if_stmt ::= 
    IF expr:a COLON suite:b {:RESULT = makeNode("if_stmt", a, b);:}
    | IF expr:a COLON suite:b ELSE COLON suite:c {: RESULT = makeNode("if_stmt", a, b, c); :}
    | IF expr:a COLON suite:b elif_stmts:c {: RESULT = makeNode("if_stmt", a, b, c); :}
    | IF expr:a COLON suite:b elif_stmts:c ELSE COLON suite:d {: RESULT = makeNode("if_stmt", a, b, c, d); :};
elif_stmts ::=
    ELIF expr:a COLON suite:b {: RESULT = makeNode("elif_stmts", a, b);:}
    | elif_stmts:list ELIF expr:a COLON suite:b {:
        list.appendChild(a);
        list.appendChild(b);
        RESULT = list;
    :};
while_stmt ::= 
    WHILE expr:a COLON suite:b {:RESULT = makeNode("while_stmt", a, b); :}
    /*| WHILE test:a COLON suite:b ELSE COLON suite:c {:
        RESULT = makeNode("while_stmt", a, b, c);
    :}*/;
try_stmt ::= 
    TRY COLON suite:a except_stmts:b {:
        RESULT = makeNode("try_stmt", a, b);
    :}
    | TRY COLON suite:a except_stmts:b ELSE COLON suite:c FINALLY COLON suite:d {:
        RESULT = makeNode("try_stmt_else_finally", a, b, c, d);
    :}
    | TRY COLON suite:a except_stmts:b ELSE COLON suite:c {:
        RESULT = makeNode("try_stmt_else", a, b, c); :}
    | TRY COLON suite:a except_stmts:b FINALLY COLON suite:c {:
        RESULT = makeNode("try_stmt_finally", a, b, c);:}
    | TRY COLON suite:a FINALLY COLON suite:b {:
        RESULT = makeNode("try_stmt_only_finally", a, b); :};
except_stmts ::=
    except_clause:a COLON suite:b {: RESULT = makeNode("except_stmts", a, b); :}
    | except_stmts:list except_clause:a COLON suite:b {:
        list.appendChild(a);
        list.appendChild(b);
        RESULT = list;
    :};

// except_clause: 'except' [test ['as' NAME]]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
except_clause ::= EXCEPT {:RESULT = makeNode("except_clause");:}
    | EXCEPT expr:a {: RESULT = makeNode("except_clause", a);:}
    | EXCEPT expr:a AS NAME:b {:RESULT = makeNode("except_clause", a, makeName(b));:};
suite ::= simple_stmt:a {:RESULT = a;:} | NEWLINE INDENT stmts:a DEDENT {:RESULT = a;:};
stmts ::=
    stmt:a {:RESULT = makeNode("stmts", a);:}
    | stmts:list stmt:b {:
        list.appendChild(b);
        RESULT = list;
    :};

expr ::=
    expr:a OR:o expr:b {:RESULT = makeNode("expr", a, makeOp(o), b);:}
    | expr:a AND:o expr:b {:RESULT = makeNode("expr", a, makeOp(o), b);:} 
    | NOT:o expr:a {:RESULT = makeNode("expr", makeOp(o), a);:}
    | expr:a comp_op:o expr:b {:RESULT = makeNode("expr", a, o, b);:} %prec COMP
    | expr:a bit_op:o expr:b {:RESULT = makeNode("expr", a, o, b);:} %prec BIT
    | expr:a addish_op:o expr:b {:RESULT = makeNode("expr", a, o, b);:} %prec ADDISH
    | expr:a mulish_op:o expr:b {:RESULT = makeNode("expr", a, o, b);:} %prec MULISH
    | unary_op:o expr:a {:RESULT = makeNode("expr", o, a);:} %prec UNARY
    | expr:a DOUBLESTAR:o expr:b {:RESULT = makeNode("expr", a, makeOp(o), b);:}
    | atom:a trailers:b {:RESULT = makeNode("expr", a, b);:}
    | atom:a {:RESULT = makeNode("expr", a);:};

// # <> isn't actually a valid comparison operator in Python. It's here for the
// # sake of a __future__ import described in PEP 401 (which really works :-)
// comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'@'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
comp_op ::= LESS {:RESULT = makeOp("LESS");:}
    | GREATER  {:RESULT = makeOp("GREATER");:}
    | EQEQUAL {:RESULT = makeOp("EQEQUAL");:}
    | GREATEREQUAL {:RESULT = makeOp("GREATEREQUAL");:}
    | LESSEQUAL {:RESULT = makeOp("LESSEQUAL");:}
    | NOTEQUAL {:RESULT = makeOp("NOTEQUAL");:}
    | IN {:RESULT = makeOp("IN");:}
    | NOT IN {:RESULT = makeOp("NOTIN");:}
    | IS {:RESULT = makeOp("IS");:}
    | IS NOT{:RESULT = makeOp("ISNOT");:} ;

bit_op ::= 
    VBAR:o {:RESULT = makeOp(o);:}
    | CIRCUMFLEX:o {:RESULT = makeOp(o);:}
    | AMPER:o {:RESULT = makeOp(o);:}
    | LEFTSHIFT:o {:RESULT = makeOp(o);:}
    | RIGHTSHIFT:o {:RESULT = makeOp(o);:};

addish_op ::=
    PLUS:o {:RESULT = makeOp(o);:}
    | MINUS:o {:RESULT = makeOp(o);:};

mulish_op ::=
    STAR:o {:RESULT = makeOp(o);:}
    | AT:o {:RESULT = makeOp(o);:}
    | PERCENT:o {:RESULT = makeOp(o);:}
    | SLASH:o {:RESULT = makeOp(o);:}
    | DOUBLESLASH:o {:RESULT = makeOp(o);:};

unary_op ::=
    PLUS:o {:RESULT = makeOp(o);:} 
    | MINUS:o {:RESULT = makeOp(o);:} 
    | TILDE:o {:RESULT = makeOp(o);:};

trailers ::=
    trailer:a {:RESULT = makeNode("trailers", a);:}
    | trailers:a trailer:b {:RESULT = makeNode("trailers", a, b);:};

atom ::= 
    LPAR RPAR {:RESULT = makeNode("atom_()");:}
    | LPAR expr:a RPAR {:RESULT = makeNode("atom_()", a);:}
    | LBRACE RBRACE {:RESULT = makeNode("atom_{}");:}
    | LBRACE dictmaker:a RBRACE {:RESULT = makeNode("atom_{}", a);:}
    | LBRACE setmaker:a RBRACE {:RESULT = makeNode("atom_{}", a);:}
    | NAME:a {:RESULT = makeNode("atom_name", makeName(a));:} 
    | labeledType:a {: RESULT = makeNode("atom_labeledType", a); :}
    | NUMBER:a {: RESULT = makeNode("atom_num", makeNumber(a));:} 
    | strings:a {:RESULT = makeNode("atom_string", a);:} 
    | ELLIPSIS:o {:RESULT = makeNode("atom", makeOp(o));:}
    | NONE:k {:RESULT = makeNode("atom", makeKeyword(k));:}
    | TRUE:k {:RESULT = makeNode("atom", makeKeyword(k));:} 
    | FALSE:k {:RESULT = makeNode("atom", makeKeyword(k));:};
strings ::=
    STRING:a {:RESULT = makeNode("strings", makeString(a));:}
    | strings:a STRING:b {:
        a.appendChild(makeString(b));
        RESULT = a;
    :};

// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
// subscript: test | [test] ':' [test] [sliceop]
// testlist: test (',' test)* [',']
// dictorsetmaker: ( ((test ':' test | '**' expr)
//                    (comp_for | (',' (test ':' test | '**' expr))* [','])) |
//                   ((test | star_expr)
//                    (comp_for | (',' (test | star_expr))* [','])) )
trailer ::= 
    LPAR RPAR {:RESULT = makeNode("trailer_()");:}
    | LPAR exprlist:a RPAR {:RESULT = makeNode("trailer_()", a);:}
    | LSQB expr:a RSQB {:RESULT = makeNode("trailer_[]", a);:}
    | DOT NAME:a {:RESULT = makeNode("trailer_.", makeName(a));:};
exprlist ::= 
    exprlist_sub:a {:RESULT = a;:} 
    | exprlist_sub:a COMMA {:RESULT = a;:};
exprlist_sub ::=
    expr:a {:RESULT = makeNode("exprlist_sub", a);:}
    //| star_expr:a {:RESULT = makeNode("exprlist_sub", a);:}
    | exprlist_sub:list COMMA expr:a {:
        list.appendChild(a);
        RESULT = a;
    :}
    /*| exprlist_sub:list COMMA star_expr:a {:
        list.appendChild(a);
        RESULT = list;
    :}*/;
dictmaker ::= 
    dictmaker_sub:a COMMA {:RESULT = a;:}
    | dictmaker_sub:a {:RESULT = a;:};
dictmaker_sub ::=
    expr:a COLON expr:b {:RESULT = makeNode("dictmaker_sub", a, b);:}
    | dictmaker_sub:list COMMA expr:a COLON expr:b {:
        list.appendChild(a);
        list.appendChild(b);
        RESULT = list;
    :};
setmaker ::=
    setmaker_sub:a {:RESULT = a;:}
    | setmaker_sub:a COMMA {:RESULT = a;:};
setmaker_sub ::=
    expr:a {:RESULT = makeNode("setmaker_sub", a);:}
    | setmaker_sub:list COMMA expr:a {:
        list.appendChild(a);
        RESULT = list;
    :};


//classdef: 'class' NAME ['(' [arglist] ')'] ':' suite
//arglist: argument (',' argument)*  [',']
classdef ::= 
    CLASS NAME LPAR exprlist:a RPAR COLON suite:b {:RESULT = makeNode("classdef", a, b);:}
    | CLASS NAME COLON suite:a {:RESULT = makeNode("classdef", a);:}
    | CLASS NAME LPAR RPAR COLON suite:a {:RESULT=  makeNode("classdef", a);:};


