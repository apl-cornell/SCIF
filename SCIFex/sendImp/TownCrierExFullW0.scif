import Callback;
import Crypto;

contract TownCrier[high] extends BaseContract {
    {trustedSend = high}
    {high => this}
    map(uint, address){high} requesters;
    map(uint, uint){high} fees;
    map(uint, address){high} callbacks;
    map(uint, bytes){high} callbackFIDs;
    map(uint, bytes){high} paramsHashes;
    
    address{high} SGX_ADDR;
    
    uint{high} GAS_PRICE;
    uint{high} MIN_FEE;
    uint{high} CANCEL_FEE;
    
    uint{high} CANCELLED_FEE_FLAG;
    uint{high} DELEVERERED_FEE_FLAG;
    uint{high} FAIL_FLAG;
    uint{high} SUCC_FLAG;
    
    bool{high} killswitch;
    
    uint{high} requestCnt;
    uint{high} unrespondedCnt;
    
    address{high} newVersion;
    Crypto{high} crypto;
    
    void init{high >> high; high}() {
        requestCnt = 1;
        requesters[0] = caller;
        killswitch = false;
        unrespondedCnt = 0;
        clear();
    }
    
    void upgrade{high >> high; high}(address{high} newAddr) {
        if {high} (caller == requesters[0] && unrespondedCnt == 0) {
            newVersion = newAddr;
            killswitch = true;
        }
        clear();
    }
    
    void reset{high >> high; high}(uint{high} price, uint{high} minGas, uint{high} cancelGas) {
        if {high} (caller == requesters[0] && unrespondedCnt == 0) {
            GAS_PRICE = price;
            MIN_FEE = price * minGas;
            CANCEL_FEE = price * cancelGas;
        }
        clear();
    }
    
    void suspend{high >> high; high}() {
        if {high} (caller == requesters[0]) {
            killswitch = true;
        }
        clear();
    }
    
    void restart{high >> high; high}() {
        if {high} (caller == requesters[0] && newVersion == EMPTY_ADDR) {
            killswitch = false;
        }
        clear();
    }
    
    void withdraw{high >> high; high}() {
        if {high} (caller == requesters[0] && unrespondedCnt == 0) {
            trustedSend(requesters[0], balance);
        }
        clear();
    }
    
    uint request{BOT >> high; BOT}(address{BOT} cb, bytes{BOT} callbackFID, uint{BOT} timestamp, bytes{BOT} requestData) {
        address gUser = caller;
        uint paid = payment;
        clear();
        
        if {high} (killswitch) {
            lock(high) {
                send(gUser, payment);
            }
            return FAIL_FLAG;
        }
        
        if {high} (paid < MIN_FEE) {
            return FAIL_FLAG;
        }
        
        uint requestId = requestCnt;
        requestCnt = requestCnt + 1;
        unrespondedCnt = unrespondedCnt + 1;
        
        bytes paramsHash = crypto.keccak256(endorse(requestData, BOT->high));
        requesters[requestId] = gUser;
        fees[requestId] = payment;
        callbacks[requestId] = endorse(cb, BOT->high);
        callbackFIDs[requestId] = endorse(callbackFID, BOT->high);
        paramsHashes[requestId] = paramsHash;
        
        return requestId;
    }
    
    void deliver{high >> high; BOT}(uint{high} requestId, bytes{high} paramsHash, uint{high} error, bytes{high} data) {
        address sender = caller;
        clear();
        
        if {high} (sender != SGX_ADDR or 
            requestId <= 0 or 
            requesters[requestId] == EMPTY_ADDR or
            fees[requestId] == DELEVERERED_FEE_FLAG) {
            return;
        }
        
        uint fee = fees[requestId];
        
        if {high} (paramsHashes[requestId] != paramsHash) {
            return;
        }
        
        if {high} (fee == CANCELLED_FEE_FLAG) {
            trustedSend(SGX_ADDR, CANCEL_FEE);
            fees[requestId] = DELEVERERED_FEE_FLAG;
            unrespondedCnt = unrespondedCnt - 1;
            return;
        }
        
        fees[requestId] = DELEVERERED_FEE_FLAG;
        unrespondedCnt = unrespondedCnt - 1;
        
        payBeforeCall(0, callbacks[requestId]);
        Callback cb = Callback(callbacks[requestId]);
        cb.call(data);
        
        if {high} (error < 2) {
            trustedSend(SGX_ADDR, fee);
        } else {
            lock(high) {
                send(requesters[requestId], fee);
            }
        }
    }
    
    uint cancel{BOT >> high; BOT}(uint{BOT} requestId) {
        address sender = caller;
        clear();
        
        if {high} (killswitch) {
            return 0;
        }
        
        uint id = endorse(requestId, BOT->high);
        uint fee = fees[id];
        
        if {high} (requesters[id] == sender && fee >= CANCEL_FEE) {
            fees[id] = CANCELLED_FEE_FLAG;
            lock(high) {
                send(sender, fee - CANCEL_FEE);
            }
            return SUCC_FLAG;
        } else {
            return FAIL_FLAG;
        }
    }
}
