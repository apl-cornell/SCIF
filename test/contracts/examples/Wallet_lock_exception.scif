contract NewWallet [this] extends Wallet {
    map(address, uint) balances;
    exception balanceNotEnough();
    exception transferFailure();

    constructor(address trustOracle, address lockOracle) {
        super(CentralizedRuntime(trustOracle, lockOracle)); // forced to be the first operation in constructors
    }

    // {BOT -> this; BOT} (t{BOT} name) return {value: this; end_pc: this}
    public void withdraw(uint amount) throw balanceNotEnough(), transferFailure() {
        Wallet a = new Wallet();

        endorse(amount, msg.sender, BOT => this) if (balances[msg.sender] >= amount) {
            lock(this) {
                try {
                    send(msg.sender, amount);
                } catch (error e) {
                    throw transferFailure();
                }
                balances[msg.sender] -= amount;
            }
        } else {
            throw balanceNotEnough();
        }
    }

    public payable void deposit() {
        endorse(msg.value, msg.sender, BOT => this) {
            balances[msg.sender] += msg.value;
        }
    }
}
