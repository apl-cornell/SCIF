import "./IERC20.scif";

contract ERC20 implements IERC20 {
    map(address, uint) balances;
    map(address owner, map(address, uint){owner}) allowances;
    // TODO: generate constraints

    @public
    bool approve{sender}(final address allowed, uint amount) {
        allowances[sender][allowed] = amount;
    }

    //
    //  dynamically check that (msg.sender join l_deputy) => from
    @public
    bool transfer{from -> this}(final address from, address to, uint amount) {
    // bool transfer{from -> this; 1}(final address from, address to, uint amount) {
        endorse([from, to, amount], from -> this)
        if (balances[from] >= amount) {
            balances[from] -= amount;
            balances[to] += amount;
            return true;
        } else {
            return false;
        }
    }

    @public
    bool{from} transferAllowed{sender -> from}(final address from, address to, uint amount) {
        endorse([from, to, amount], sender -> from)
        if (allowances[from][sender] >= amount) {
            if (transfer(from, to, amount)) {
                allowances[from][sender] -= amount;
                return true;
            }
        }
        return false;
    }
}