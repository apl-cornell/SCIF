import Token;

contract Uniswap[this] {
    {{
        BaseContractCentralized;
        {@tX = this}
        {@tY = this}
    }}
    Token{this} tX;
    Token{this} tY;
    exception transferFailure();
    exception uncheckable();

    Uniswap constructor{this >> this; this}(address tO, address lO, address tokenX, address tokenY) {
        @BaseContractCentralized(tO, lO);

        tX = Token(tokenX);
        tY = Token(tokenY);
    }

    @public
    uint{this} exchangeXForY{BOT >> this; this}(uint xSold) throw (transferFailure{BOT}) {
        address buyer = msg.sender;
        uint tXSold = endorse(xSold, BOT->high);

        uint prod = getBal(tX, address(this)) * getBal(tY, address(this));
        uint yKept = prod / (getBal(tX, address(this)) + tXSold);
        uint yBought = getBal(tY, address(this)) - yKept;
        try {
            tX.transfer(buyer, address(this), tXSold);
            tY.transfer(address(this), buyer, yBought);
        } catch (Token.balanceNotEnough{BOT} e) {
            throw transferFailure();
            // throw uncheckable();
        } catch (Token.balanceNotEnoughs{BOT} e) {
            throw transferFailure();
        }

        return yBought;
    }

    @public
    uint{this} getBal{this >> this; this}(Token token, address k) {
        // uint getBal(address x) throws noSuchUser();
        return token.getBal(k);
    } 
}

