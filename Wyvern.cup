import java.io.*;
import java_cup.runtime.*;
import java.util.*;
import ast.*;
import com.owlike.genson.Genson;
import com.owlike.genson.GensonBuilder;
import utils.CodeLocation;

parser code {:
    public boolean DEBUG = true;

    public void syntax_error(Symbol cur_token) {
        System.err.println("Syntax error at " + cur_token);
        report_error("Syntax error", cur_token);
    }

    public void Debuglog(String s) {
        if (DEBUG)
            System.out.println(s);
    }

    /*public Node<String> makeKeyword(Object kw) {
        if (kw instanceof String)
            return new Node<String>((String)kw, -1, -1);
        Symbol tmp = (Symbol) kw;
        return new Node<String>(tmp.toString(), tmp.left, tmp.right);
    }*/

    public static void main(String args[]) {
        File inputFile = new File(args[0]);
        parse(inputFile, null);
    }

    public static void parse(File inputFile, File astFile) {
        try {
            Lexer lexer = new Lexer(new FileReader(inputFile));

            if (astFile != null) {
                PrintStream ps = new PrintStream(new FileOutputStream(astFile));
                System.setErr(ps);
            }

            Parser p = new Parser(lexer);
            System.out.println("Parser init\n");

            p.parse();
            //p.debug_parse();

            System.out.println("Finish\n");

            if (astFile != null) {
                System.setErr(System.err);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
:};

terminal ERROR;
terminal NUMBER, STRING;
terminal FALSE, TRUE, NONE, NAME, ELLIPSIS;
terminal AND, AS, ASSERT, ASYNC, AWAIT;
terminal BREAK, CLASS, CONTINUE, DEF, DEL;
terminal ELIF, ELSE, EXCEPT, FINALLY, FOR, FROM;
terminal GLOBAL, IF, IMPORT, IN, IS, LAMBDA, NONLOCAL, NOT;
terminal OR, PASS, RAISE, RETURN, TRY;
terminal WHILE, WITH, YIELD;
terminal LPAR, RPAR, LSQB, RSQB, COLON, COMMA, SEMI;
terminal PLUS, MINUS, STAR, SLASH, VBAR, AMPER;
terminal LESS, GREATER, EQUAL, DOT, PERCENT, LBRACE, RBRACE;
terminal CIRCUMFLEX, TILDE, AT;
terminal EQEQUAL, NOTEQUAL, LESSEQUAL, LEFTSHIFT, GREATEREQUAL, RIGHTSHIFT;
terminal PLUSEQUAL, MINEQUAL, RARROW, DOUBLESTAR, STAREQUAL, DOUBLESLASH, SLASHEQUAL, VBAREQUAL;
terminal PERCENTEQUAL, AMPEREQUAL, CIRCUMFLEXEQUAL, ATEQUAL;
terminal LEFTSHIFTEQUAL, RIGHTSHIFTEQUAL, DOUBLESTAREQUAL, DOUBLESLASHEQUAL;
terminal INT, NEWLINE;
terminal INDENT, DEDENT;
terminal UNARY, COMP, BIT, ADDISH, MULISH;
terminal ENDORSE, AUTOENDORSE;

nonterminal Program program;
nonterminal ArrayList<Statement> file_input;
//nonterminal Node<String> file_input_unit;
nonterminal Expression decorator;
nonterminal ArrayList<Expression> decorators;
nonterminal FunctionDef decorated, funcdef;
nonterminal Arguments parameters, typedarglist, probinittfpdef;
nonterminal Arg tfpdef;
nonterminal ArrayList<Statement> stmt, simple_stmt, small_stmts;
nonterminal Statement small_stmt, expr_stmt;
nonterminal AnnAssign annassign;
nonterminal Statement del_stmt, pass_stmt, flow_stmt, break_stmt, continue_stmt, return_stmt, raise_stmt, ipt_stmt;
nonterminal Import ipt_name;
nonterminal Name ipt_as_names;
nonterminal Statement assert_stmt, compound_stmt;
nonterminal Statement if_stmt, while_stmt, try_stmt;
nonterminal ArrayList<Statement> elif_stmts;
nonterminal ArrayList<ExceptHandler> except_stmts;
nonterminal ExceptHandler except_clause;
nonterminal ArrayList<Statement> suite, stmts;
nonterminal Expression expr;
nonterminal CompareOperator comp_op;
nonterminal BinaryOperator bit_op, addish_op, mulish_op;
nonterminal UnaryOperator unary_op;
//nonterminal ArrayList<Expression> trailers;
nonterminal TrailerExpr trailer_expr;
nonterminal Expression atom;
nonterminal Str strings;
nonterminal TrailerExpr trailer;
nonterminal ArrayList<Expression> exprlist, exprlist_sub;
nonterminal Dictmaker dictmaker, dictmaker_sub;
nonterminal Setmaker setmaker, setmaker_sub;
nonterminal ClassDef classdef;
nonterminal Call arglist;
nonterminal Keyword keyword;
nonterminal Expression labeledType;
nonterminal IfLabel ifLabel, unitIfLabel;
nonterminal Expression maybeLabeledName;
nonterminal Autoendorse autoendorse;
nonterminal IfLabel maybeAutoendorseIfLabel;
nonterminal Endorse endorseExpression;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence left COMP, LESS, GREATER, EQEQUAL, GREATEREQUAL, LESSEQUAL, NOTEQUAL, IN, IS;
precedence left BIT, VBAR, CIRCUMFLEX, AMPER, LEFTSHIFT, RIGHTSHIFT;
precedence left ADDISH, PLUS, MINUS;
precedence left MULISH, STAR, AT, PERCENT, SLASH, DOUBLESLASH;
precedence left UNARY;
precedence left LPAR, RPAR, LSQB, RSQB, LBRACE, RBRACE;
precedence right DOUBLESTAR;


start with program;

program ::= file_input:list {:
        RESULT = new Program(list);
        RESULT.setLoc(new CodeLocation(listleft, listright));
        System.err.println(RESULT);
    :};

//Information flow specific modification
endorseExpression ::= ENDORSE:x LPAR expr:a COMMA ifLabel:from COMMA ifLabel:to RPAR {:
        RESULT = new Endorse(a, from, to);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};

labeledType ::= NAME:a LBRACE ifLabel:b RBRACE {:
        //System.out.println("parsed labeledType with label: \n" + b.toString());
        Name name = new Name((String)a);
        name.setLoc(new CodeLocation(aleft, aright));
        RESULT = new LabeledType(name, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
maybeAutoendorseIfLabel ::= autoendorse:a {:
        RESULT = a;
    :}
    | ifLabel:a {:
        RESULT = a;
    :};

autoendorse ::= AUTOENDORSE:x LPAR ifLabel:from COMMA ifLabel:to RPAR {:
        RESULT = new Autoendorse(from, to);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};

ifLabel ::= unitIfLabel:a {:
        RESULT = a;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :} 
    | ifLabel:a AND ifLabel:b {:
        RESULT = new ComplexIfLabel(a, IfOperator.MEET, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | ifLabel:a OR ifLabel:b {:
        RESULT = new ComplexIfLabel(a, IfOperator.JOIN, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
unitIfLabel ::= NAME:a {:
        Name name = new Name((String)a);
        name.setLoc(new CodeLocation(aleft, aright));
        RESULT = new PrimitiveIfLabel(name);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | LPAR ifLabel:a RPAR {:
        RESULT = a;
    :};

decorator ::= AT:x NAME:a NEWLINE {:
        RESULT = new Name((String)a);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
decorators ::= 
    decorator:a {:
        ArrayList<Expression> rnt = new ArrayList<Expression>();
        rnt.add(a);
        RESULT = rnt;
    :}
    | decorators:list decorator:a {:
        list.add(a);
        RESULT = list;
    :};
decorated ::= 
    decorators:a classdef:b {:RESULT = null; :}
    | decorators:a funcdef:b {:
        b.setDecoratorList(a);
        RESULT = b;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};

//file_input: (NEWLINE | stmt)* ENDMARKER
file_input ::= 
    file_input:fi stmt:fiu {: 
        Debuglog("Debug: 1");
        ArrayList<Statement> list = fi;
        list.addAll(fiu);
        RESULT = list;
    :}
    | stmt:a {:
        Debuglog("Debug: 2");
        RESULT = a;
    :};

//file_input_unit ::= NEWLINE {: RESULT = makeNode("NEWLINE"); :}
//    | stmt:a {: RESULT = a; :};

//eval_input: testlist NEWLINE* ENDMARKER


//funcdef: 'def' NAME parameters ['->' test] ':' suite
funcdef ::= 
    DEF:x maybeLabeledName:a parameters:b RARROW expr:c COLON suite:d {:
        RESULT = new FunctionDef(a, b, d, null, c);
        RESULT.setLoc(new CodeLocation(xleft, xright));
        //makeNode("funcdef", a, b, c, d);
    :}
    | DEF:x maybeLabeledName:a parameters:b COLON suite:c {:
        System.out.println("parsing function");
        RESULT = new FunctionDef(a, b, c, null, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
maybeLabeledName ::=
    NAME:a {:
        RESULT = new Name((String)a);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | NAME:a LBRACE maybeAutoendorseIfLabel:b RBRACE {:
        Name name = new Name((String)a);
        name.setLoc(new CodeLocation(aleft, aright));
        RESULT = new LabeledType(name, b); //TODO
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};


//parameters: '(' [typedargslist] ')'
//typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
//        '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
//      | '**' tfpdef [',']]]
//  | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
//  | '**' tfpdef [','])
//tfpdef: NAME [':' test]
parameters ::= 
    LPAR typedarglist:a RPAR {:
        RESULT = a;
    :}
    | LPAR:a RPAR {:
        RESULT = new Arguments();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
typedarglist ::=
    probinittfpdef:a {:RESULT = a; :}
    | typedarglist:list COMMA probinittfpdef:a {:
        list.merge(a);
        RESULT = list;
    :}; 
probinittfpdef ::=
    tfpdef:a  {:
        ArrayList<Arg> args = new ArrayList<Arg>();
        args.add(a);
        RESULT = new Arguments(args, null);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | tfpdef:a EQUAL expr:b {:
        ArrayList<Arg> args = new ArrayList<Arg>();
        ArrayList<Expression> defaults = new ArrayList<Expression>();
        args.add(a);
        defaults.add(b);
        RESULT = new Arguments(args, defaults);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
tfpdef ::= 
    NAME:a COLON expr:b {:
        Name name = new Name((String)a);
        name.setLoc(new CodeLocation(aleft, aright));
        RESULT = new Arg(name, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};

//stmt: simple_stmt | compound_stmt
//simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
//small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |
//             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
//expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
//                     ('=' (yield_expr|testlist_star_expr))*)
stmt ::= simple_stmt:a {: RESULT = a; :}
    | compound_stmt:a {:
        ArrayList<Statement> rnt = new ArrayList<Statement>();
        rnt.add(a);
        RESULT = rnt;
    :};
simple_stmt ::= small_stmts:a SEMI NEWLINE {: RESULT = a; :}
    | small_stmts:a NEWLINE {: RESULT = a; :}
    | NEWLINE:x {:
        RESULT = new ArrayList<Statement>();
    :};
small_stmts ::=
    small_stmt:a {:
        ArrayList<Statement> list = new ArrayList<Statement>();
        list.add(a);
        RESULT = list;
    :}
    | small_stmts:list SEMI small_stmt:a {:
        list.add(a);
        RESULT = list;
    :};
small_stmt ::= expr_stmt:a {: RESULT = a; :}
    | del_stmt:a {: RESULT = a; :}
    | pass_stmt:a {: RESULT = a; :}  
    | flow_stmt:a {: RESULT = a; :}  
    | ipt_stmt:a {: RESULT = a; :}  
    | assert_stmt:a {: RESULT = a; :} ;
expr_stmt ::= 
    expr:a {:RESULT = a;:}
    | expr:a annassign:b {://testlist_star_expr:a expr_rest_stmt:b {:
        b.setTarget(a);
        if (a instanceof Name) {
            b.setSimple(true);
        }
        RESULT = b;
    :}
    | expr:a EQUAL expr:b {:
        ArrayList<Expression> list = new ArrayList<Expression>();
        list.add(a);
        Assign rnt = new Assign(list, b);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};

//annassign: ':' test ['=' test]
//testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
//augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
//            '<<=' | '>>=' | '**=' | '//=')
annassign ::= 
    COLON expr:a EQUAL expr:b {:
        //System.out.println("Annassign case 1 parsing");
        AnnAssign rnt = new AnnAssign(null, a, b, false);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | COLON expr:a {:
        //System.out.println("Annassign case 2 parsing");
        AnnAssign rnt = new AnnAssign(null, a, null, false);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};

//# For normal and annotated assignments, additional restrictions enforced by the interpreter
// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]
// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
del_stmt ::= DEL:x exprlist:a {:
            RESULT = new Delete(a);
            RESULT.setLoc(new CodeLocation(xleft, xright));
        :};
pass_stmt ::= PASS:a {:
        RESULT = new Pass();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
flow_stmt ::= break_stmt:a {: RESULT = a;:}
        | continue_stmt:a {: RESULT = a;:}  
        | return_stmt:a {: RESULT = a;:}
        | raise_stmt:a {: RESULT = a;:};
break_stmt ::= BREAK:a {:
        RESULT = new Break();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
continue_stmt ::= CONTINUE:a {:
        RESULT = new Continue();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
return_stmt ::= RETURN:a {:
        RESULT = new Return();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | RETURN:x expr:a {:
        RESULT = new Return(a);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
raise_stmt ::= RAISE:a {:
        RESULT = new Raise();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | RAISE:x expr:a {:
        RESULT = new Raise(a);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | RAISE:x expr:a FROM expr:b {:
        RESULT = new Raise(a, b);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
ipt_stmt ::= ipt_name:a {: RESULT = a; :};
ipt_name ::= IMPORT:x ipt_as_names:a {:
        RESULT = new Import();
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};


// # note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
// import_as_name: NAME ['as' NAME]
// assert_stmt: 'assert' expr [',' expr]
ipt_as_names ::= 
    NAME:a {:
        RESULT = new Name((String)a);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | NAME:a AS NAME:b {:
        RESULT = new Name((String)a); //TODO
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
assert_stmt ::= ASSERT:x expr:a COMMA expr:b {:
        RESULT = new Assert(a, b);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | ASSERT:x expr:a {:
        RESULT = new Assert(a, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};


// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// try_stmt: ('try' ':' suite
//            ((except_clause ':' suite)+
//             ['else' ':' suite]
//             ['finally' ':' suite] |
//            'finally' ':' suite))
compound_stmt ::= if_stmt:a {:RESULT = a;:} 
    | while_stmt:a {:RESULT = a;:}
    | try_stmt:a {:RESULT = a;:} 
    | funcdef:a {:RESULT = a;:} 
    | classdef:a {:RESULT = a;:}
    | decorated:a {:RESULT = a;:}; 
if_stmt ::= 
    IF:x expr:a COLON suite:b {:
        RESULT = new If(a, b);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | IF:x expr:a COLON suite:b ELSE COLON suite:c {:
        RESULT = new If(a, b, c);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | IF:x expr:a COLON suite:b elif_stmts:c {:
        RESULT = new If(a, b, c);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | IF:x expr:a COLON suite:b elif_stmts:c ELSE COLON suite:d {:
        RESULT = null; //TODO
    :};
elif_stmts ::=
    ELIF:x expr:a COLON suite:b {:
        ArrayList<Statement> rnt = new ArrayList<Statement>();
        If elif = new If(a, b);
        elif.setLoc(new CodeLocation(xleft, xright));
        rnt.add(elif);
        RESULT = rnt;
    :}
    | elif_stmts:list ELIF expr:a COLON suite:b {:
        RESULT = null; //TODO
    :};
while_stmt ::= 
    WHILE:x expr:a COLON suite:b {:
        //System.out.println("while stmt parsed");
        RESULT = new While(a, b, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    /*| WHILE test:a COLON suite:b ELSE COLON suite:c {:
        RESULT = makeNode("while_stmt", a, b, c);
    :}*/;
try_stmt ::= 
    TRY:x COLON suite:a except_stmts:b {:
        RESULT = new Try(a, b, null, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | TRY:x COLON suite:a except_stmts:b ELSE COLON suite:c FINALLY COLON suite:d {:
        RESULT = new Try(a, b, c, d);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | TRY:x COLON suite:a except_stmts:b ELSE COLON suite:c {:
        RESULT = new Try(a, b, c, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | TRY:x COLON suite:a except_stmts:b FINALLY COLON suite:c {:
        RESULT = new Try(a, b, null, c);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | TRY:x COLON suite:a FINALLY COLON suite:b {:
        RESULT = new Try(a, null, null, b);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
except_stmts ::=
    except_clause:a COLON suite:b {:
        ArrayList<ExceptHandler> rnt = new ArrayList<ExceptHandler>();
        a.setBody(b);
        rnt.add(a);
        RESULT = rnt;
    :}
    | except_stmts:rnt except_clause:a COLON suite:b {:
        a.setBody(b);
        rnt.add(a);
        RESULT = rnt;
    :};

// except_clause: 'except' [test ['as' NAME]]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
except_clause ::= EXCEPT:x {:
        RESULT = new ExceptHandler(null, null, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | EXCEPT:x expr:a {:
        RESULT = new ExceptHandler(a, null, null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | EXCEPT:x expr:a AS NAME:b {:
        RESULT = new ExceptHandler(a, new Str((String)b), null);
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
suite ::= simple_stmt:a {:RESULT = a;:} | NEWLINE INDENT stmts:a DEDENT {:RESULT = a;:};
stmts ::=
    stmt:a {:
        RESULT = a;
    :}
    | stmts:list stmt:b {:
        list.addAll(b);
        RESULT = list;
    :};

expr ::=
    expr:a OR:o expr:b {:
        RESULT = new BoolOp(a, BoolOperator.Or, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | expr:a AND:o expr:b {:
        RESULT = new BoolOp(a, BoolOperator.And, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | NOT:o expr:a {:
        RESULT = new UnaryOp(UnaryOperator.Not, a);
        RESULT.setLoc(new CodeLocation(oleft, oright));
    :}
    | expr:a comp_op:o expr:b {:
        //System.out.println("compare expr parsed");
        RESULT = new Compare(a, o, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :} %prec COMP
    | expr:a bit_op:o expr:b {:
        RESULT = new BinOp(a, o, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :} %prec BIT
    | expr:a addish_op:o expr:b {:
        RESULT = new BinOp(a, o, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :} %prec ADDISH
    | expr:a mulish_op:o expr:b {:
        RESULT = new BinOp(a, o, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :} %prec MULISH
    | unary_op:o expr:a {:
        RESULT = new UnaryOp(o, a);
        RESULT.setLoc(new CodeLocation(oleft, oright));
    :} %prec UNARY
    | expr:a DOUBLESTAR:o expr:b {:
        RESULT = new BinOp(a, BinaryOperator.Pow, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | trailer_expr:a {:RESULT = a; :}
    | atom:a {:
        //System.out.println("atom expr parsed");
        RESULT = a;
    :};

// # <> isn't actually a valid comparison operator in Python. It's here for the
// # sake of a __future__ import described in PEP 401 (which really works :-)
// comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'@'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
comp_op ::= LESS {:RESULT = CompareOperator.Lt; :}
    | GREATER  {:RESULT = CompareOperator.Gt;:}
    | EQEQUAL {:RESULT = CompareOperator.Eq;:}
    | GREATEREQUAL {:RESULT = CompareOperator.GtE;:}
    | LESSEQUAL {:RESULT = CompareOperator.LtE;:}
    | NOTEQUAL {:RESULT = CompareOperator.NotEq;:}
    | IN {:
        //System.out.println("IN comp op parsed");
        RESULT = CompareOperator.In;
    :}
    | NOT IN {:RESULT = CompareOperator.NotIn;:}
    | IS {:RESULT = CompareOperator.Is;:}
    | IS NOT{:RESULT = CompareOperator.IsNot;:} ;

bit_op ::= 
    VBAR:o {:RESULT = BinaryOperator.BitOr;:}
    | CIRCUMFLEX:o {:RESULT = BinaryOperator.BitXor;:}
    | AMPER:o {:RESULT = BinaryOperator.BitAnd;:}
    | LEFTSHIFT:o {:RESULT = BinaryOperator.Lshift;:}
    | RIGHTSHIFT:o {:RESULT = BinaryOperator.Rshift;:};

addish_op ::=
    PLUS:o {:RESULT = BinaryOperator.Add;:}
    | MINUS:o {:RESULT = BinaryOperator.Sub;:};

mulish_op ::=
    STAR:o {:RESULT = BinaryOperator.Mult;:}
    | AT:o {:RESULT = BinaryOperator.MatMult;:}
    | PERCENT:o {:RESULT = BinaryOperator.Mod;:}
    | SLASH:o {:RESULT = BinaryOperator.Div;:}
    | DOUBLESLASH:o {:RESULT = BinaryOperator.FloorDiv;:};

unary_op ::=
    PLUS:o {:RESULT = UnaryOperator.UAdd;:}
    | MINUS:o {:RESULT = UnaryOperator.USub;:}
    | TILDE:o {:RESULT = UnaryOperator.Invert;:};

trailer_expr ::=
    atom:a trailer:b {:
        b.setValue(a);
        RESULT = b;
    :}
    | trailer_expr:a trailer:b {:
        b.setValue(a);
        RESULT = b;
    :};
/*trailers ::=
    trailer:a {:
        ArrayList<Expression> rnt = new ArrayList<Expression>();
        rnt.add(a);
        RESULT = rnt;
    :}
    | trailers:a trailer:b {:
        a.add(b);
        RESULT = a;
    :};*/

atom ::= 
    LPAR:a RPAR {:
        RESULT = new Expression();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | LPAR expr:a RPAR {:RESULT = a; :}
    | LBRACE:a RBRACE {:
        RESULT = new Expression();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | LBRACE dictmaker:a RBRACE {:RESULT = a;:}
    | LBRACE setmaker:a RBRACE {:RESULT = a;:}
    | NAME:a {:
        RESULT = new Name((String)a);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | labeledType:a {: RESULT = a; :}
    | NUMBER:a {:
        RESULT = new Num<Integer>(Integer.valueOf((String)a));
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | strings:a {:RESULT = a;:}
    | ELLIPSIS:o {:RESULT = null;:}
    | NONE:k {:
        RESULT = new ConstantExpr(Constant.NONE);
        RESULT.setLoc(new CodeLocation(kleft, kright));
    :}
    | TRUE:k {:
        RESULT = new ConstantExpr(Constant.TRUE);
        RESULT.setLoc(new CodeLocation(kleft, kright));
    :}
    | FALSE:k {:
        RESULT = new ConstantExpr(Constant.FALSE);
        RESULT.setLoc(new CodeLocation(kleft, kright));
    :}
    | endorseExpression:a {:
        RESULT = a;
    :};
strings ::=
    STRING:a {:
        RESULT = new Str((String)a);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    /*| strings:a STRING:b {:
        RESULT = null; //TODO
    :}*/;

// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
// subscript: test | [test] ':' [test] [sliceop]
// testlist: test (',' test)* [',']
// dictorsetmaker: ( ((test ':' test | '**' expr)
//                    (comp_for | (',' (test ':' test | '**' expr))* [','])) |
//                   ((test | star_expr)
//                    (comp_for | (',' (test | star_expr))* [','])) )
trailer ::= 
    LPAR:a RPAR {:
        RESULT = new Call();
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | LPAR arglist:a RPAR {:
        RESULT = a;
    :}
    | LSQB expr:a RSQB {:
        RESULT = new Subscript(null, a, null);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | DOT NAME:a {:
        Name name = new Name((String)a);
        name.setLoc(new CodeLocation(aleft, aright));
        RESULT = new Attribute(null, name, null);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};
exprlist ::= 
    exprlist_sub:a {:RESULT = a;:} 
    | exprlist_sub:a COMMA {:RESULT = a;:};
exprlist_sub ::=
    expr:a {:
        ArrayList<Expression> rnt = new ArrayList<Expression>();
        rnt.add(a);
        RESULT = rnt;
    :}
    //| star_expr:a {:RESULT = makeNode("exprlist_sub", a);:}
    | exprlist_sub:list COMMA expr:a {:
        list.add(a);
        RESULT = list;
    :}
    /*| exprlist_sub:list COMMA star_expr:a {:
        list.appendChild(a);
        RESULT = list;
    :}*/;
dictmaker ::= 
    dictmaker_sub:a COMMA {:RESULT = a;:}
    | dictmaker_sub:a {:RESULT = a;:};
dictmaker_sub ::=
    expr:a COLON expr:b {:
        Dictmaker rnt = new Dictmaker();
        rnt.addPair(a, b);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | dictmaker_sub:list COMMA expr:a COLON expr:b {:
        list.addPair(a, b);
        RESULT = list;
    :};
setmaker ::=
    setmaker_sub:a {:RESULT = a;:}
    | setmaker_sub:a COMMA {:RESULT = a;:};
setmaker_sub ::=
    expr:a {:
        Setmaker rnt = new Setmaker();
        rnt.addElement(a);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | setmaker_sub:list COMMA expr:a {:
        list.addElement(a);
        RESULT = list;
    :};


//classdef: 'class' NAME ['(' [arglist] ')'] ':' suite
//arglist: argument (',' argument)*  [',']
classdef ::= 
    CLASS:x NAME:name LPAR arglist:a RPAR COLON suite:b {:
        RESULT = new ClassDef();
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | CLASS:x NAME:name COLON suite:a {:
        RESULT = new ClassDef();
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :}
    | CLASS:x NAME:name LPAR RPAR COLON suite:a {:
        RESULT = new ClassDef();
        RESULT.setLoc(new CodeLocation(xleft, xright));
    :};
arglist ::=
    keyword:a {:
        Call rnt = new Call();
        rnt.addKeyword(a);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | expr:a {:
        //System.out.println("parsing first arg for arglist");
        Call rnt = new Call();
        rnt.addArg(a);
        RESULT = rnt;
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :}
    | arglist:list COMMA keyword:a {:
        list.addKeyword(a);
        RESULT = list;
    :}
    | arglist:list COMMA expr:a {:
        //System.out.println("parsing one more arg for arglist");
        list.addArg(a);
        RESULT = list;
    :};

keyword ::=
    NAME:a EQUAL expr:b {:
        RESULT = new Keyword((String)a, b);
        RESULT.setLoc(new CodeLocation(aleft, aright));
    :};



